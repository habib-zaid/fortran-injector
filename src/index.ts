import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import { glob } from 'glob';
import iconv from 'iconv-lite';
import { nativeTheme } from 'electron';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Keep a global reference of the window object.
let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1000,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // Load the webpack-bundled app
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development.
  if (process.argv.includes('--dev')) {
    mainWindow.webContents.openDevTools();
  }

  // Emitted when the window is closed.
  mainWindow.on('closed', () => {
    mainWindow = null;
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
app.whenReady().then(createWindow);

// Quit when all windows are closed, except on macOS.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// IPC handlers
ipcMain.handle('open-directory-dialog', async () => {
  const result = await dialog.showOpenDialog(mainWindow!, {
    properties: ['openDirectory']
  });
  
  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths[0];
  }
  return null;
});

ipcMain.handle('open-output-directory-dialog', async () => {
  const result = await dialog.showOpenDialog(mainWindow!, {
    properties: ['openDirectory'],
    title: 'Select Output Directory for CSV Files'
  });
  
  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths[0];
  }
  return null;
});

ipcMain.handle('search-and-inject', async (event, functionName: string, workspacePath: string) => {
  try {
    // Send status update
    mainWindow?.webContents.send('status-update', 'Searching for Fortran files...', 'info');
    
    // Find all Fortran files
    const fortranFiles = await findFortranFiles(workspacePath);
    
    if (fortranFiles.length === 0) {
      mainWindow?.webContents.send('status-update', 'No Fortran files found', 'error');
      return;
    }
    
    mainWindow?.webContents.send('status-update', `Found ${fortranFiles.length} Fortran files`, 'info');
    
    // Search for function calls and inject write statements
    const results = await processFortranFiles(fortranFiles, functionName);
    
    // Send results back to renderer
    mainWindow?.webContents.send('search-results', results);
    
    if (results.length > 0) {
      mainWindow?.webContents.send('status-update', 
        `Successfully processed ${results.length} function calls`, 'success');
    } else {
      mainWindow?.webContents.send('status-update', 
        `No function calls to '${functionName}' found`, 'info');
    }
    
  } catch (error) {
    console.error('Error processing Fortran files:', error);
    mainWindow?.webContents.send('status-update', 
      `Error: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');
  }
});

ipcMain.handle('export-to-csv', async (event, results: any[], outputPath: string, filename: string) => {
  try {
    const csvContent = generateCsvContent(results);
    const fullPath = path.join(outputPath, filename);
    
    await fs.promises.writeFile(fullPath, csvContent, 'utf8');
    
    mainWindow?.webContents.send('csv-export-complete', true, fullPath);
    return true;
  } catch (error) {
    console.error('Error exporting CSV:', error);
    mainWindow?.webContents.send('csv-export-complete', false, error instanceof Error ? error.message : 'Unknown error');
    return false;
  }
});

// Theme management
ipcMain.handle('dark-mode:toggle', () => {
  if (nativeTheme.shouldUseDarkColors) {
    nativeTheme.themeSource = 'light';
  } else {
    nativeTheme.themeSource = 'dark';
  }
  return nativeTheme.shouldUseDarkColors;
});

ipcMain.handle('dark-mode:system', () => {
  nativeTheme.themeSource = 'system';
});

ipcMain.handle('dark-mode:get', () => {
  return {
    shouldUseDarkColors: nativeTheme.shouldUseDarkColors,
    themeSource: nativeTheme.themeSource
  };
});

// New method for 3-way theme cycling
ipcMain.handle('dark-mode:cycle', (event, currentMode: string) => {
  if (currentMode === 'system') {
    nativeTheme.themeSource = 'dark';
    return 'dark';
  } else if (currentMode === 'dark') {
    nativeTheme.themeSource = 'light';
    return 'light';
  } else {
    nativeTheme.themeSource = 'system';
    return 'system';
  }
});

function generateCsvContent(results: any[]): string {
  const headers = ['Line', 'Function Call', 'Parameters'];
  const csvRows = [headers.join('|')];
  
  results.forEach(result => {
    const row = [
      result.lineNumber,
      result.functionCall,
      result.parameters.join(', ')
    ];
    csvRows.push(row.join('|'));
  });
  
  return csvRows.join('\n');
}

async function findFortranFiles(workspacePath: string): Promise<string[]> {
  try {
    const files = await glob('**/*.{f,F,f90,F90,f95,F95}', { cwd: workspacePath });
    return files.map(file => path.join(workspacePath, file));
  } catch (error) {
    console.error('Error finding Fortran files:', error);
    return [];
  }
}

async function processFortranFiles(files: string[], functionName: string): Promise<any[]> {
  const results: any[] = [];
  
  for (const file of files) {
    try {
      const fileResults = await processFortranFile(file, functionName);
      results.push(...fileResults);
    } catch (error) {
      console.error(`Error processing file ${file}:`, error);
    }
  }
  
  return results;
}

async function processFortranFile(filePath: string, functionName: string): Promise<any[]> {
  const results: any[] = [];
  
  try {
    // Read file as buffer first, then try to decode
    const buffer = await fs.promises.readFile(filePath);
    let content: string;
    
    // Try to decode as Shift-JIS, fallback to utf8 if it fails
    try {
      // Use iconv-lite or similar for proper Shift-JIS support
      // For now, just use utf8 and handle encoding issues gracefully
      content = iconv.decode(buffer, 'shift-jis');
    } catch {
      content = buffer.toString('utf8');
    }
    
    const lines = content.split('\n');
    
    const fileName = path.basename(filePath);
    let modified = false;
    
    // Search for function calls
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Look for "call function_name (params)" pattern
      const callPattern = new RegExp(`\\s*call\\s+${functionName}\\s*\\(([^)]*)\\)`, 'i');
      const match = line.match(callPattern);
      
      if (match) {
        const params = match[1].split(',').map(p => p.trim()).filter(p => p);
        
        // Check if we already have a write statement above
        if (i > 0 && !lines[i-1].trim().startsWith('write')) {
          // Get the original indentation from the function call line
          const originalIndent = line.match(/^(\s*)/)?.[1] || '     ';
          
          // Insert write statement above with matching indentation
          const writeStatement = `${originalIndent}write(${params.join(', ')})`;
          lines.splice(i, 0, writeStatement);
          modified = true;
          
          results.push({
            fileName,
            lineNumber: i + 1,
            functionCall: line.trim(),
            parameters: params,
            status: 'Injected write statement'
          });
          
          // Adjust line numbers for subsequent matches
          i++;
        } else {
          results.push({
            fileName,
            lineNumber: i + 1,
            functionCall: line.trim(),
            parameters: params,
            status: 'Write statement already exists'
          });
        }
      }
    }
    
    // Write back to file if modified
    if (modified) {
      const newContent = lines.join('\n');
      await fs.promises.writeFile(filePath, newContent, 'utf8');
    }
    
  } catch (error) {
    console.error(`Error processing file ${filePath}:`, error);
    results.push({
      fileName: path.basename(filePath),
      lineNumber: 0,
      functionCall: '',
      parameters: [],
      status: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`
    });
  }
  
  return results;
}
